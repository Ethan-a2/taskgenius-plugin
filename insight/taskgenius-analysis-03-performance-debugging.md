# Task Genius 性能瓶颈分析与调试

日期：2026-01-22

## 潜在性能瓶颈

1. 全量索引与重解析
   - 现象：Vault 文件较多（N 大）时，初次或变更触发的全量扫描与解析耗时显著。
   - 原因：TaskParser 对每个文件逐行解析，复杂度 O(N*T)。
   - 影响：UI 阻塞或渲染延迟（若 Worker 与主线程协调不当）。

2. 过滤/分组链式计算
   - 现象：多条件过滤 + 分组 + 排序在大型任务集合上响应慢。
   - 原因：策略组合多、未做索引或缓存；每次视图切换重复计算。

3. 渲染器与视图重复渲染
   - 现象：Widgets 频繁重渲染；看板/日历节点过多导致布局计算密集。
   - 原因：缺乏细粒度的 diff/虚拟化；状态更新节流不足。

4. 存储与缓存（localforage）
   - 现象：读写频繁、缓存膨胀导致 I/O 变慢。
   - 原因：缺少过期清理策略与容量控制；序列化成本。

5. 编辑器扩展交互
   - 现象：状态循环/过滤器在大文档上操作迟滞。
   - 原因：选择器与状态计算逐字符或逐行扫描；未区分可见区域。

## 调试与排查步骤

1. 建立性能基线
   - 启动 performance markers（console.time/console.timeEnd 在非 prod）围绕：索引、解析、过滤、渲染、写回。
   - 在 test-setup 与核心模块添加轻量日志开关（基于环境变量）。

2. 索引/解析
   - 采样：统计每批次解析耗时（文件数、行数、任务数）。
   - 检查增量逻辑：仅对变更文件解析；引入文件哈希/mtime 快速跳过。
   - 评估 Worker 通讯：消息频率与批量大小；避免主线程风暴。

3. 过滤/分组/排序
   - 分解计算链：为每个策略计时；识别最慢的几步（Top-K）。
   - 引入 memoization：基于过滤参数与数据快照 key 做结果缓存。
   - 预索引：为常用键（状态、日期、标签）构建索引表以 O(1)/O(logN) 查询。

4. 渲染优化
   - 虚拟化长列表：仅渲染可视区域 + 预渲染缓冲。
   - 去抖/节流：用户交互触发批量更新，合并短时间内多次刷新。
   - 细粒度更新：按任务行或卡片 diff 更新而非整视图重绘。

5. 缓存与持久化
   - 容量管理：设置缓存上限与 LRU 淘汰；按视图分区缓存。
   - 异步批量写：合并写操作，减少频繁 I/O。
   - 监控命中率与序列化时间，优化数据结构（如减少嵌套对象）。

6. 编辑器扩展
   - 可见窗口优化：仅对可见行范围应用状态/过滤器。
   - 事件节流：键入/滚动事件处理节流到 16-32ms。
   - 预解析：对常用语法做快速路径，复杂语法延迟处理。

7. 工具与测试
   - 使用 Jest 基准测试（test/perf/）对关键函数做 micro-benchmark。
   - 在 CI 中加入性能回归阈值（例如单测中耗时断言）。

---

建议引入的度量点示例：
- indexer:scan_batch(ms), indexer:parse_file(ms), repo:query(ms)
- filters:apply(ms), grouping:build(ms), sorting:run(ms)
- renderer:update(ms), view:diff(ms), cm:status_cycle(ms)
- cache:write(ms), cache:read(ms), cache:hit_rate(%)
